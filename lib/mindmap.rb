class File
    # open_mm is a File.open on steroids. It opens the mind map file and writes the begining and end tags as well as the comment with the program writing this mindmap
    def self.open_mm(*args)
      io=File.open(*args)
      io.write("<map version=\"0.9.0\">\n")
      io.write("<!-- Mind Map generated by the mindmap ruby gem -->\n")
      $spaces=0
      yield io
      io.write("</map>\n")
      io.close()
    end
  
    # the options couls include everything you would use in a mindmap node. Common ones are:
    # => Font options: :font_name, :font_size, :font_bold, :font_italic
    # => Icon options: ["help","messagebox_warning","idea","button_ok","button_cancel","full-1","full-2","full-3","full-4","full-5","full-6","full-7","back",
    # => => "forward","attach",,"ksmiletris","clanbomber","desktop_new","flag","gohome","kaddressbook","knotify","korn","Mail","password","pencil","stop","wizard","xmag",
    # => => "bell","bookmark","penguin","licq"]
    # => Cloud options: :cloud (generic option to draw a cloud around the node), :cloud_color (the color for the cloud)
    # => node options: :text, :collapsed, :color (html format), :background_color (html format)
    def node(options={})
      parameters=[]
      font={}
      edge={}
      cloud=nil
      icons=[]
      options.each {|option,value|
      if value
        if option==:icon
          value.each {|icon|
            icons.push("#{" ".rjust($spaces+2," ")}<icon BUILTIN=\"#{icon}\"/>")
          }
        elsif [:font_size,:font_name,:font_bold,:font_italic,].include?(option)
          font[option.to_s.sub(/font_/,"")]=value
        elsif option==:cloud
          cloud={}
        elsif [:cloud_color].include?(option)
          cloud={} unless cloud
          cloud[option.to_s.sub(/cloud_/,"")]=value
        elsif [:edge_width,:edge_color,:edge_style].include?(option)
          edge[option.to_s.sub(/edge_/,"")]=value
        else
          parameters.push("#{option.to_s.upcase}=\"#{value}\"")
        end
	  end
      }
      if block_given? or not font.empty? or not icons.empty? or (cloud and not cloud.empy?) or not edge.empty?
        self.write("#{' '.rjust($spaces," ")}<node CREATED=\"#{Time.now.to_i}#{rand(899)+100}\" ID=\"scenario_#{options[:text].to_s.gsub(/[\.\ ]/,"_")}#{rand(3000)}\" MODIFIED=\"#{Time.now.to_i}#{rand(999)}\" #{parameters.join(" ")}>\n")
        $spaces+=2
        unless edge.empty?
          self.write("#{" ".rjust($spaces," ")}<edge ")
          edge.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write("/>\n")
        end
        self.write icons.join("\n")+"\n" unless icons.empty?
        if cloud
          self.write("#{" ".rjust($spaces," ")}<cloud ")
          cloud.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write("/>\n")
        end
        unless font.empty?
          self.write("#{" ".rjust($spaces," ")}<font ")
          font.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write "NAME=\"SansSerif\" "unless font[:name]
          self.write "SIZE=\"12\"" unless font[:size]
          self.write("/>\n")
        end
        yield self if block_given?
        $spaces-=2
        self.write("#{" ".rjust($spaces," ")}</node>\n")
      else
        self.write("#{" ".rjust($spaces," ")}<node CREATED=\"#{Time.now.to_i}#{rand(899)+100}\" ID=\"scenario_#{options[:text].to_s.gsub(/[\.\ ]/,"_")}#{rand(3000)}\" MODIFIED=\"#{Time.now.to_i}#{rand(999)}\" #{parameters.join(" ")}\/>\n")
      end
    end
    
    def enum_to_mm(enumerable)
      if enumerable.class==Hash
        enumerable.each {|keys,values|
          folded = ($spaces >= 10 ? "false" : "true")
          ccolor=$cloud_color[keys] if $spaces >= 5 and $cloud_color
          node(:text=>keys,:folded=>folded, :cloud_color=>ccolor){|enu_node|
            enum_to_mm(values)
          }
        }
      elsif enumerable.class==Array
        enumerable.each {|element|
          node(:text=>element)
        }
      elsif enumerable.class!=NilClass
        node(:text=>enumerable)
      end
    end
    
   end
  
  # traverse the binary tree and populate it with values from the row. If I want special functions done with some columns, we'll use them as the last function
  # Potential commands: 
  # :count  - counts the occurences for the nodes
  # :sum    - sums the bits in the last column
  # :append - appends current value to the values present
  # :max    - reassigns the value as long as the value is greater than the current one
  # :min    - reassigns the value as long as the value is lesser than the current one
  def traverse_tree(tree_level,nodes,row_hash)
    if nodes.length==1 and nodes.last.class==Hash
      nodes.last.each {|instruction,columns|
      columns.each {|column|      
        case instruction
        when :count
          tree_level[column]=tree_level[column].to_i+1
        when :sum
          tree_level[column]=tree_level[column].to_i+row_hash[column].to_i
        when :append
          tree_level[column]=tree_level[column].to_a.push(row_hash[column])
        when :max
          tree_level[column]=row_hash[column] if not tree_level[column] or row_hash[column]>tree_level[column].to_s
        when :min
          tree_level[column]=row_hash[column] if not tree_level[column] or row_hash[column]<tree_level[column].to_s 
        end
      }
      }
      
    elsif nodes.length==2 and nodes.last.class!=Hash
      tree_level[row_hash[nodes.first]]=row_hash[nodes.last]
    elsif (nodes.length>1 and nodes.last.class==Hash) or (nodes.length>1 and nodes.last.class!=Hash)
      current_node=nodes.delete_at(0)
      tree_level[row_hash[current_node]]={} unless tree_level[row_hash[current_node]]
      traverse_tree(tree_level[row_hash[current_node]],nodes, row_hash)
    end
    end
    