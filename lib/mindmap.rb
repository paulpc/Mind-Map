class File
    # open_mm is a File.open on steroids. It opens the mind map file and writes the begining and end tags as well as the comment with the program writing this mindmap
    def self.open_mm(*args)
      io=File.open(*args)
      io.write("<map version=\"0.9.0\">\n")
      io.write("<!-- Mind Map generated by the mindmap ruby gem -->\n")
      $spaces=0
      yield io
      io.write("</map>\n")
      io.close()
    end
  
    # the options couls include everything you would use in a mindmap node. Common ones are:
    # => Font options: :font_name, :font_size, :font_bold, :font_italic
    # => Icon options: ["help","messagebox_warning","idea","button_ok","button_cancel","full-1","full-2","full-3","full-4","full-5","full-6","full-7","back",
    # => => "forward","attach",,"ksmiletris","clanbomber","desktop_new","flag","gohome","kaddressbook","knotify","korn","Mail","password","pencil","stop","wizard","xmag",
    # => => "bell","bookmark","penguin","licq"]
    # => Cloud options: :cloud (generic option to draw a cloud around the node), :cloud_color (the color for the cloud)
    # => node options: :text, :collapsed, :color (html format), :background_color (html format)
    def node(options={})
      parameters=[]
      font={}
      edge={}
      cloud=nil
      icons=[]
      options.each {|option,value|
      if value
        if option==:icon
          value.each {|icon|
            icons.push("#{" ".rjust($spaces+2," ")}<icon BUILTIN=\"#{icon}\"/>")
          }
        elsif [:font_size,:font_name,:font_bold,:font_italic,].include?(option)
          font[option.to_s.sub(/font_/,"")]=value
        elsif option==:cloud
          cloud={}
        elsif [:cloud_color].include?(option)
          cloud={} unless cloud
          cloud[option.to_s.sub(/cloud_/,"")]=value
        elsif [:edge_width,:edge_color,:edge_style].include?(option)
          edge[option.to_s.sub(/edge_/,"")]=value
        else
          parameters.push("#{option.to_s.upcase}=\"#{value}\"")
        end
	  end
      }
      if block_given? or not font.empty? or not icons.empty? or (cloud and not cloud.empy?) or not edge.empty?
        self.write("#{' '.rjust($spaces," ")}<node CREATED=\"#{Time.now.to_i}#{rand(899)+100}\" ID=\"scenario_#{options[:text].to_s.gsub(/[\.\ ]/,"_")}#{rand(3000)}\" MODIFIED=\"#{Time.now.to_i}#{rand(999)}\" #{parameters.join(" ")}>\n")
        $spaces+=2
        unless edge.empty?
          self.write("#{" ".rjust($spaces," ")}<edge ")
          edge.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write("/>\n")
        end
        self.write icons.join("\n")+"\n" unless icons.empty?
        if cloud
          self.write("#{" ".rjust($spaces," ")}<cloud ")
          cloud.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write("/>\n")
        end
        unless font.empty?
          self.write("#{" ".rjust($spaces," ")}<font ")
          font.each {|option,value|
            self.write("#{option.upcase}=\"#{value}\" ")
          }
          self.write "NAME=\"SansSerif\" "unless font[:name]
          self.write "SIZE=\"12\"" unless font[:size]
          self.write("/>\n")
        end
        yield self if block_given?
        $spaces-=2
        self.write("#{" ".rjust($spaces," ")}</node>\n")
      else
        self.write("#{" ".rjust($spaces," ")}<node CREATED=\"#{Time.now.to_i}#{rand(899)+100}\" ID=\"scenario_#{options[:text].to_s.gsub(/[\.\ ]/,"_")}#{rand(3000)}\" MODIFIED=\"#{Time.now.to_i}#{rand(999)}\" #{parameters.join(" ")}\/>\n")
      end
    end
    
    def enum_to_mm(enumerable)
      if enumerable.class==Hash
        enumerable.each {|keys,values|
          folded = ($spaces >= 8 ? "false" : "true")
		  ccolor=$cloud_color[keys] if $spaces >= 5
          node(:text=>keys,:folded=>folded, :cloud_color=>ccolor){|enu_node|
            enum_to_mm(values)
          }
        }
      elsif enumerable.class==Array
        enumerable.each {|element|
          node(:text=>element)
        }
      elsif enumerable.class!=NilClass
        node(:text=>enumerable)
      end
    end
    
    def traverse_tree(parent, nodes,row_hash)
      if nodes.empty?
        parent["bytes"]["source"]+=row_hash["totalSourceBytes"].to_i
        parent["bytes"]["destination"]+=row_hash["totalDestinationBytes"].to_i
        parent["packets"]["source"]+=row_hash["totalSourcePackets"].to_i
        parent["packets"]["destination"]+=row_hash["totalDestinationPackets"].to_i
        parent["startTime"][row_hash["startTime"]]=(Time.at((Float(row_hash["startTime"])/1000).to_i))
      else
      next_node=nodes.delete_at(0)
      if next_node.empty?
        parent[next_node]={"bytes"=>{"source"=>0,"destination"=>0},"packets"=>{"source"=>0,"destination"=>0},"startTime"=>{}}  unless parent[next_node]
      else
      parent[next_node]={} unless parent[next_node]
      end
      traverse_tree(parent[next_node],nodes)
      end
    end
    
    def create_enum(row_hash,known_nodes, unknown_nodes)
      if unknown_nodes.empty?
        
      end
    end

  end